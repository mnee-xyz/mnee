import{Utils as t,LockingScript as e,OP as r,TransactionSignature as o,Hash as n,UnlockingScript as s,Transaction as i,PublicKey as a,Script as c,P2PKH as u,PrivateKey as d}from"@bsv/sdk";import*as f from"js-1sat-ord";class p{lock(o,n){let s=[];if("string"==typeof o){const e=t.fromBase58Check(o);if(0!==e.prefix[0]&&111!==e.prefix[0])throw new Error("only P2PKH is supported");s=e.data}else s=o;const i=new e;return i.writeOpCode(r.OP_DUP).writeOpCode(r.OP_HASH160).writeBin(s).writeOpCode(r.OP_EQUALVERIFY).writeOpCode(r.OP_CHECKSIGVERIFY).writeBin(n.encode(!0)).writeOpCode(r.OP_CHECKSIG),i}userUnlock(t,e="all",r=!1,i,a){return{sign:async function(c,u){var d,f,p;let h=o.SIGHASH_FORKID;"all"===e&&(h|=o.SIGHASH_ALL),"none"===e&&(h|=o.SIGHASH_NONE),"single"===e&&(h|=o.SIGHASH_SINGLE),r&&(h|=o.SIGHASH_ANYONECANPAY);const l=c.inputs[u],g=c.inputs.filter((t,e)=>e!==u),m=l.sourceTXID?l.sourceTXID:null==(d=l.sourceTransaction)?void 0:d.id("hex");if(!m)throw new Error("The input sourceTXID or sourceTransaction is required for transaction signing.");if(i||(i=null==(f=l.sourceTransaction)?void 0:f.outputs[l.sourceOutputIndex].satoshis),!i)throw new Error("The sourceSatoshis or input sourceTransaction is required for transaction signing.");if(a||(a=null==(p=l.sourceTransaction)?void 0:p.outputs[l.sourceOutputIndex].lockingScript),!a)throw new Error("The lockingScript or input sourceTransaction is required for transaction signing.");const w=o.format({sourceTXID:m,sourceOutputIndex:l.sourceOutputIndex,sourceSatoshis:i,transactionVersion:c.version,otherInputs:g,inputIndex:u,outputs:c.outputs,inputSequence:l.sequence||4294967295,subscript:a,lockTime:c.lockTime,scope:h}),I=t.sign(n.sha256(w)),v=new o(I.r,I.s,h),T=new s;return T.writeBin(v.toChecksigFormat()),T.writeBin(t.toPublicKey().encode(!0)),T},estimateLength:async function(){return 182}}}unlock(t,e,r="all",i=!1,a,c){return{sign:async function(u,d){var f,p,h;let l=o.SIGHASH_FORKID;"all"===r&&(l|=o.SIGHASH_ALL),"none"===r&&(l|=o.SIGHASH_NONE),"single"===r&&(l|=o.SIGHASH_SINGLE),i&&(l|=o.SIGHASH_ANYONECANPAY);const g=u.inputs[d],m=u.inputs.filter((t,e)=>e!==d),w=g.sourceTXID?g.sourceTXID:null==(f=g.sourceTransaction)?void 0:f.id("hex");if(!w)throw new Error("The input sourceTXID or sourceTransaction is required for transaction signing.");if(a||(a=null==(p=g.sourceTransaction)?void 0:p.outputs[g.sourceOutputIndex].satoshis),!a)throw new Error("The sourceSatoshis or input sourceTransaction is required for transaction signing.");if(c||(c=null==(h=g.sourceTransaction)?void 0:h.outputs[g.sourceOutputIndex].lockingScript),!c)throw new Error("The lockingScript or input sourceTransaction is required for transaction signing.");const I=o.format({sourceTXID:w,sourceOutputIndex:g.sourceOutputIndex,sourceSatoshis:a,transactionVersion:u.version,otherInputs:m,inputIndex:d,outputs:u.outputs,inputSequence:g.sequence||4294967295,subscript:c,lockTime:u.lockTime,scope:l}),v=t.sign(n.sha256(I)),T=new o(v.r,v.s,l),x=new s;return x.writeBin(T.toChecksigFormat()),x.writeScript(e),x},estimateLength:async function(){return 182}}}}const h=e=>{var o,s;let i;for(let o=0;o<e.chunks.length;o++){var a;const n=e.chunks[o];o>=2&&3===(null==(a=n.data)?void 0:a.length)&&"ord"==t.toUTF8(n.data)&&e.chunks[o-1].op==r.OP_IF&&e.chunks[o-2].op==r.OP_FALSE&&(i=o+1)}if(void 0===i)return;const c={file:{hash:"",size:0,type:""},fields:{}};for(let a=i;a<e.chunks.length;a+=2){var u,d;const i=e.chunks[a];if(i.op==r.OP_ENDIF)break;if(i.op>r.OP_16)return;const f=e.chunks[a+1];if(f.op>r.OP_PUSHDATA4)return;if(null!=(u=i.data)&&u.length)continue;let p=0;switch(i.op>r.OP_PUSHDATA4&&i.op<=r.OP_16?p=i.op-80:null!=(d=i.data)&&d.length&&(p=i.data[0]),p){case 0:if(c.file.size=(null==(o=f.data)?void 0:o.length)||0,null==(s=f.data)||!s.length)break;c.file.hash=t.toBase64(n.sha256(f.data)),c.file.content=f.data;break;case 1:c.file.type=Buffer.from(f.data||[]).toString()}}return c},l=e=>e.map(e=>{const o=e.chunks;for(let e=0;e<=o.length-4;e++){var n,s,i;if(o.length>e+6&&o[0+e].op===r.OP_DUP&&o[1+e].op===r.OP_HASH160&&20===(null==(n=o[2+e].data)?void 0:n.length)&&o[3+e].op===r.OP_EQUALVERIFY&&o[4+e].op===r.OP_CHECKSIGVERIFY&&33===(null==(s=o[5+e].data)?void 0:s.length)&&o[6+e].op===r.OP_CHECKSIG)return{cosigner:t.toHex(o[5+e].data||[]),address:t.toBase58Check(o[2+e].data||[],[0])};if(o[0+e].op===r.OP_DUP&&o[1+e].op===r.OP_HASH160&&20===(null==(i=o[2+e].data)?void 0:i.length)&&o[3+e].op===r.OP_EQUALVERIFY&&o[4+e].op===r.OP_CHECKSIG)return{cosigner:"",address:t.toBase58Check(o[2+e].data||[],[0])}}}),g=(e,r,o)=>{const n=e.senders.includes(r)?"send":"receive",s=e.height>0?"confirmed":"unconfirmed";if(!e.rawtx)return null;const a=t.toArray(e.rawtx,"base64"),c=t.toHex(a),u=i.fromHex(c).outputs.map(t=>t.lockingScript),d=l(u),f=u.map(h),p=d.map(t=>t.address),g=p.indexOf(o.feeAddress),m=e.senders[0];let w=0;const I=new Map;f.forEach((e,n)=>{var s;const i=null==e||null==(s=e.file)?void 0:s.content;if(!i)return;const a=t.toUTF8(i);if(!a)return;let c;try{c=JSON.parse(a)}catch(t){return void console.error("Failed to parse inscription JSON:",t)}if("bsv-20"!==c.p||c.id!==o.tokenId)return;const u=parseInt(c.amt,10);if(Number.isNaN(u))return;if(g===n&&m===r)return void(w+=u);const d=p[n],f=I.get(d)||0;I.set(d,f+u)});const v=I.get(r)||0;if("send"===n){const t=I.get(m)||0;I.set(m,t-v)}let T=[];T="receive"===n?[{address:m,amount:v}]:Array.from(I.entries()).map(([t,e])=>({address:t,amount:e})).filter(t=>t.address!==r&&t.address!==o.feeAddress&&t.amount>0);const x=T.reduce((t,e)=>t+e.amount,0);return{txid:e.txid,height:e.height,type:n,status:s,amount:x,fee:w,score:e.score,counterparties:T}};class m{constructor(t){this.mneeApiToken="92982ec1c0975f31979da515d46bae9f",this.prodTokenId="ae59f3b898ec61acbdb6cc7a245fabeded0c094bf046f35206a3aec60ef88127_0",this.prodApprover="020a177d6a5e6f3a8689acd2e313bd1cf0dcf5a243d1cc67b7218602aee9e04b2f",this.mneeApi="https://proxy-api.mnee.net",this.gorillaPoolApi="https://ordinals.1sat.app",this.mneeConfig=void 0,t&&(this.mneeApiToken=t),this.getConfig()}async getConfig(){try{const t=await fetch(`${this.mneeApi}/v1/config?auth_token=${this.mneeApiToken}`,{method:"GET"});if(!t.ok)throw new Error(`HTTP error! status: ${t.status}`);const e=await t.json();return this.mneeConfig=e,e}catch(t){return void console.error("Failed to fetch config:",t)}}toAtomicAmount(t){if(!this.mneeConfig)throw new Error("Config not fetched");return Math.round(t*10**this.mneeConfig.decimals)}fromAtomicAmount(t){if(!this.mneeConfig)throw new Error("Config not fetched");return t/10**this.mneeConfig.decimals}async createInscription(t,e,r){const o={p:"bsv-20",op:"transfer",id:r.tokenId,amt:e.toString()};return{lockingScript:f.applyInscription((new p).lock(t,a.fromString(r.approver)),{dataB64:Buffer.from(JSON.stringify(o)).toString("base64"),contentType:"application/bsv-20"}),satoshis:1}}async getUtxos(t,e=["transfer","deploy+mint"]){try{const r=await fetch(`${this.mneeApi}/v1/utxos?auth_token=${this.mneeApiToken}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([t])});if(!r.ok)throw new Error(`HTTP error! status: ${r.status}`);const o=await r.json();return e.length?o.filter(t=>e.includes(t.data.bsv21.op.toLowerCase())):o}catch(t){return console.error("Failed to fetch UTXOs:",t),[]}}async broadcast(t){const e=`${this.gorillaPoolApi}/v5/tx`;try{const r=await fetch(e,{method:"POST",headers:{"Content-Type":"application/octet-stream"},body:Buffer.from(t.toBinary())}),o=await r.json();return r.ok?{status:"success",txid:o.txid,message:"Transaction broadcast successfully"}:{status:"error",code:r.status.toString(),description:o.error||"Unknown error"}}catch(t){return console.error("Failed to broadcast:",t),{status:"error",code:"UNKNOWN",description:t instanceof Error?t.message:"Unknown error"}}}async fetchBeef(t){const e=await fetch(`${this.gorillaPoolApi}/v5/tx/${t}/beef`);if(404===e.status)throw new Error("Transaction not found");if(200!==e.status)throw new Error(`${e.status} - Failed to fetch beef for tx ${t}`);const r=[...Buffer.from(await e.arrayBuffer())];return i.fromAtomicBEEF(r)}async getSignatures(e,r){try{const s=65;let a;switch(e.format){case"beef":a=i.fromHexBEEF(e.rawtx);break;case"ef":a=i.fromHexEF(e.rawtx);break;default:a=i.fromHex(e.rawtx)}const d=e.sigRequests.flatMap(e=>[r].map(r=>{const i=o.format({sourceTXID:e.prevTxid,sourceOutputIndex:e.outputIndex,sourceSatoshis:e.satoshis,transactionVersion:a.version,otherInputs:a.inputs.filter((t,r)=>r!==e.inputIndex),inputIndex:e.inputIndex,outputs:a.outputs,inputSequence:a.inputs[e.inputIndex].sequence||0,subscript:e.script?c.fromHex(e.script):(new u).lock(r.toPublicKey().toAddress()),lockTime:a.lockTime,scope:e.sigHashType||s}),d=r.sign(n.sha256(i)),f=new o(d.r,d.s,e.sigHashType||s);return{sig:t.toHex(f.toChecksigFormat()),pubKey:r.toPublicKey().toString(),inputIndex:e.inputIndex,sigHashType:e.sigHashType||s,csIdx:e.csIdx}}));return Promise.resolve({sigResponses:d})}catch(t){var s;return console.error("getSignatures error",t),{error:{message:null!=(s=t.message)?s:"unknown",cause:t.cause}}}}async transfer(e,r){try{var n;const a=this.mneeConfig||await this.getConfig();if(!a)throw new Error("Config not fetched");const u=e.reduce((t,e)=>t+e.amount,0);if(u<=0)return{error:"Invalid amount"};const f=this.toAtomicAmount(u),p=d.fromWif(r),h=p.toAddress(),l=await this.getUtxos(h);if(l.reduce((t,e)=>t+(e.data.bsv21.amt||0),0)<f)return{error:"Insufficient MNEE balance"};const g=void 0!==e.find(t=>t.address===a.burnAddress)?0:null==(n=a.fees.find(t=>f>=t.min&&f<=t.max))?void 0:n.fee;if(void 0===g)return{error:"Fee ranges inadequate"};const m=new i(1,[],[],0);let w=0;const I=[];let v="";for(;w<f+g;){const t=l.shift();if(!t)return{error:"Insufficient MNEE balance"};const e=await this.fetchBeef(t.txid);if(!e)return{error:"Failed to fetch source transaction"};I.push(t.owners[0]),v=v||t.owners[0],m.addInput({sourceTXID:t.txid,sourceOutputIndex:t.vout,sourceTransaction:e,unlockingScript:new s}),w+=t.data.bsv21.amt}for(const t of e)m.addOutput(await this.createInscription(t.address,this.toAtomicAmount(t.amount),a));g>0&&m.addOutput(await this.createInscription(a.feeAddress,g,a));const T=w-f-g;T>0&&m.addOutput(await this.createInscription(v,T,a));const x=m.inputs.map((t,e)=>{var r,n;if(!t.sourceTXID)throw new Error("Source TXID is undefined");return{prevTxid:t.sourceTXID,outputIndex:t.sourceOutputIndex,inputIndex:e,address:I[e],script:null==(r=t.sourceTransaction)?void 0:r.outputs[t.sourceOutputIndex].lockingScript.toHex(),satoshis:(null==(n=t.sourceTransaction)?void 0:n.outputs[t.sourceOutputIndex].satoshis)||1,sigHashType:o.SIGHASH_ALL|o.SIGHASH_ANYONECANPAY|o.SIGHASH_FORKID}}),S=m.toHex(),A=await this.getSignatures({rawtx:S,sigRequests:x},p);if(null==A||!A.sigResponses)return{error:"Failed to get signatures"};for(const e of A.sigResponses)m.inputs[e.inputIndex].unlockingScript=(new c).writeBin(t.toArray(e.sig,"hex")).writeBin(t.toArray(e.pubKey,"hex"));const y=t.toBase64(m.toBinary()),k=await fetch(`${this.mneeApi}/v1/transfer?auth_token=${this.mneeApiToken}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({rawtx:y})});if(!k.ok)throw new Error(`HTTP error! status: ${k.status}`);const{rawtx:E}=await k.json();if(!E)return{error:"Failed to broadcast transaction"};const O=t.toArray(E,"base64"),H=i.fromBinary(O);return await this.broadcast(H),{txid:H.id("hex"),rawtx:t.toHex(O)}}catch(t){let e="Transaction submission failed";return t instanceof Error&&(e=t.message,t.message.includes("HTTP error")&&console.error("HTTP error details:",t)),console.error("Failed to transfer tokens:",e),{error:e}}}async getBalance(t){try{if(!this.mneeConfig&&!await this.getConfig())throw new Error("Config not fetched");const e=(await this.getUtxos(t)).reduce((t,e)=>("transfer"===e.data.bsv21.op&&(t+=e.data.bsv21.amt),t),0);return{amount:e,decimalAmount:this.fromAtomicAmount(e)}}catch(t){return console.error("Failed to fetch balance:",t),{amount:0,decimalAmount:0}}}async validateMneeTx(e,r){try{const o=this.mneeConfig||await this.getConfig();if(!o)throw new Error("Config not fetched");const n=i.fromHex(e),s=n.outputs.map(t=>t.lockingScript),a=l(s);return r?r.forEach((e,r)=>{var s;const{address:i,amount:c}=e;if(!a.find(t=>(null==t?void 0:t.cosigner)===o.approver))throw new Error(`Cosigner not found for address: ${i} at index: ${r}`);if(!a.find(t=>(null==t?void 0:t.address)===i))throw new Error(`Address not found in script for address: ${i} at index: ${r}`);const u=h(n.outputs[r].lockingScript),d=null==u||null==(s=u.file)?void 0:s.content;if(!d)throw new Error("Invalid inscription content");const f=t.toUTF8(d);if(!f)throw new Error("Invalid inscription content");const p=JSON.parse(f);if("bsv-20"!==p.p)throw new Error(`Invalid bsv 20 protocol: ${p.p}`);if("transfer"!==p.op)throw new Error(`Invalid operation: ${p.op}`);if(p.id!==o.tokenId)throw new Error(`Invalid token id: ${p.id}`);if(p.amt!==this.toAtomicAmount(c).toString())throw new Error(`Invalid amount: ${p.amt}`)}):a.forEach(t=>{if(""!==(null==t?void 0:t.cosigner)&&(null==t?void 0:t.cosigner)!==o.approver)throw new Error("Invalid or missing cosigner")}),!0}catch(t){return console.error(t),!1}}async getMneeSyncs(t,e=0,r=100){try{const o=await fetch(`${this.mneeApi}/v1/sync?auth_token=${this.mneeApiToken}&from=${e}&limit=${r}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([t])});if(!o.ok)throw new Error(`HTTP error! status: ${o.status}`);return await o.json()}catch(t){return void console.error("Failed to fetch config:",t)}}async getRecentTxHistory(t,e,r){try{const o=this.mneeConfig||await this.getConfig();if(!o)throw new Error("Config not fetched");const n=await this.getMneeSyncs(t,e,r);if(!n||0===n.length)return{history:[],nextScore:e||0};const s=[];for(const e of n){const r=g(e,t,o);r&&s.push(r)}const i=s.sort((t,e)=>e.height-t.height).sort((t,e)=>"unconfirmed"===t.status?-1:1);return 0===i.length?{history:[],nextScore:e||0}:r&&i.length>r?{history:i.slice(0,r),nextScore:i[r-1].score}:{history:i,nextScore:s[s.length-1].score}}catch(t){return console.error("Failed to fetch tx history:",t),{history:[],nextScore:e||0}}}async parseTx(e){const r=this.mneeConfig||await this.getConfig();if(!r)throw new Error("Config not fetched");const o=await this.fetchBeef(e);if(!o)throw new Error("Failed to fetch transaction");const n=o.outputs.map(t=>t.lockingScript),s=o.inputs.map(t=>({txid:t.sourceTXID,vout:t.sourceOutputIndex}));let i=[],a=[],c=0n,u=0n,d="prod",f="transfer";for(const o of s){var p;if(!o.txid)continue;const n=(await this.fetchBeef(o.txid)).outputs[o.vout],s=l([n.lockingScript])[0];(null==s?void 0:s.address)===r.mintAddress&&(f=e===r.tokenId.split("_")[0]?"deploy":"mint");const a=h(n.lockingScript),u=null==a||null==(p=a.file)?void 0:p.content;if(!u)continue;const g=t.toUTF8(u);if(!g)continue;const m=JSON.parse(g);m&&(m.id===this.prodTokenId&&s.cosigner===this.prodApprover||(d="test"),c+=BigInt(m.amt),i.push({address:s.address,amount:parseInt(m.amt)}))}for(const e of n){var g;const r=l([e])[0],o=h(e),n=null==o||null==(g=o.file)?void 0:g.content;if(!n)continue;const s=t.toUTF8(n);if(!s)continue;const i=JSON.parse(s);i&&("burn"===i.op&&(f="burn"),i.id===this.prodTokenId&&r.cosigner===this.prodApprover||(d="test"),u+=BigInt(i.amt),a.push({address:r.address,amount:parseInt(i.amt)}))}if(r.tokenId.split("_")[0]!==e&&c!==u)throw new Error("Inputs and outputs are not equal");return{txid:e,environment:d,type:f,inputs:i,outputs:a}}}class w{constructor(t){this.service=void 0,this.service=new m(t)}async validateMneeTx(t,e){return this.service.validateMneeTx(t,e)}toAtomicAmount(t){return this.service.toAtomicAmount(t)}fromAtomicAmount(t){return this.service.fromAtomicAmount(t)}async config(){return this.service.getConfig()}async balance(t){return this.service.getBalance(t)}async transfer(t,e){return this.service.transfer(t,e)}async recentTxHistory(t,e,r){return this.service.getRecentTxHistory(t,e,r)}async parseTx(t){return this.service.parseTx(t)}}export{w as default};
//# sourceMappingURL=index.modern.js.map
