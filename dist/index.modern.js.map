{"version":3,"file":"index.modern.js","sources":["../src/mneeCosignTemplate.ts","../src/utils/helper.ts","../src/mneeService.ts","../src/index.ts"],"sourcesContent":["import {\n  Hash,\n  LockingScript,\n  OP,\n  type PrivateKey,\n  type PublicKey,\n  type Script,\n  type ScriptTemplate,\n  type Transaction,\n  TransactionSignature,\n  UnlockingScript,\n  Utils,\n} from \"@bsv/sdk\";\n\n/**\n * P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.\n */\nexport default class CosignTemplate implements ScriptTemplate {\n  /**\n   * Creates a P2PKH locking script for a given public key hash or address string\n   *\n   * @param {number[] | string} userPKHash or address - An array or address representing the public key hash of the owning user.\n   * @param {PublicKey} approverPubKey - Public key of the approver.\n   * @returns {LockingScript} - A P2PKH locking script.\n   */\n  lock(\n    userPKHash: string | number[],\n    approverPubKey: PublicKey\n  ): LockingScript {\n    let pkhash: number[] = [];\n    if (typeof userPKHash === \"string\") {\n      const hash = Utils.fromBase58Check(userPKHash);\n      if (hash.prefix[0] !== 0x00 && hash.prefix[0] !== 0x6f)\n        throw new Error(\"only P2PKH is supported\");\n      pkhash = hash.data as number[];\n    } else {\n      pkhash = userPKHash;\n    }\n    const lockingScript = new LockingScript();\n    lockingScript\n      .writeOpCode(OP.OP_DUP)\n      .writeOpCode(OP.OP_HASH160)\n      .writeBin(pkhash)\n      .writeOpCode(OP.OP_EQUALVERIFY)\n      .writeOpCode(OP.OP_CHECKSIGVERIFY)\n      .writeBin(approverPubKey.encode(true) as number[])\n      .writeOpCode(OP.OP_CHECKSIG);\n\n    return lockingScript;\n  }\n\n  /**\n   * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n   *\n   * The returned object contains:\n   * 1. `sign` - A function that, when invoked with a transaction and an input index,\n   *    produces an unlocking script suitable for a P2PKH locked output.\n   * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n   *\n   * @param {PrivateKey} userPrivateKey - The private key used for signing the transaction.\n   * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n   * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n   * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n   * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n   * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n   */\n  userUnlock(\n    userPrivateKey: PrivateKey,\n    signOutputs: \"all\" | \"none\" | \"single\" = \"all\",\n    anyoneCanPay = false,\n    sourceSatoshis?: number,\n    lockingScript?: Script\n  ): {\n    sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>;\n    estimateLength: () => Promise<182>;\n  } {\n    return {\n      sign: async (tx: Transaction, inputIndex: number) => {\n        let signatureScope = TransactionSignature.SIGHASH_FORKID;\n        if (signOutputs === \"all\") {\n          signatureScope |= TransactionSignature.SIGHASH_ALL;\n        }\n        if (signOutputs === \"none\") {\n          signatureScope |= TransactionSignature.SIGHASH_NONE;\n        }\n        if (signOutputs === \"single\") {\n          signatureScope |= TransactionSignature.SIGHASH_SINGLE;\n        }\n        if (anyoneCanPay) {\n          signatureScope |= TransactionSignature.SIGHASH_ANYONECANPAY;\n        }\n\n        const input = tx.inputs[inputIndex];\n\n        const otherInputs = tx.inputs.filter(\n          (_, index) => index !== inputIndex\n        );\n\n        const sourceTXID = input.sourceTXID\n          ? input.sourceTXID\n          : input.sourceTransaction?.id(\"hex\");\n        if (!sourceTXID) {\n          throw new Error(\n            \"The input sourceTXID or sourceTransaction is required for transaction signing.\"\n          );\n        }\n        sourceSatoshis ||=\n          input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis;\n        if (!sourceSatoshis) {\n          throw new Error(\n            \"The sourceSatoshis or input sourceTransaction is required for transaction signing.\"\n          );\n        }\n        lockingScript ||=\n          input.sourceTransaction?.outputs[input.sourceOutputIndex]\n            .lockingScript;\n        if (!lockingScript) {\n          throw new Error(\n            \"The lockingScript or input sourceTransaction is required for transaction signing.\"\n          );\n        }\n\n        const preimage = TransactionSignature.format({\n          sourceTXID,\n          sourceOutputIndex: input.sourceOutputIndex,\n          sourceSatoshis,\n          transactionVersion: tx.version,\n          otherInputs,\n          inputIndex,\n          outputs: tx.outputs,\n          inputSequence: input.sequence || 0xffffffff,\n          subscript: lockingScript,\n          lockTime: tx.lockTime,\n          scope: signatureScope,\n        });\n        const rawSignature = userPrivateKey.sign(Hash.sha256(preimage));\n        const sig = new TransactionSignature(\n          rawSignature.r,\n          rawSignature.s,\n          signatureScope\n        );\n        const unlockScript = new UnlockingScript();\n        unlockScript.writeBin(sig.toChecksigFormat());\n        unlockScript.writeBin(\n          userPrivateKey.toPublicKey().encode(true) as number[]\n        );\n        return unlockScript;\n      },\n      estimateLength: async () => {\n        // public key (1+33) + signature (1+73) + approver signature (1+73)\n        // Note: We add 1 to each element's length because of the associated OP_PUSH\n        return 182;\n      },\n    };\n  }\n\n  /**\n   * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n   *\n   * The returned object contains:\n   * 1. `sign` - A function that, when invoked with a transaction and an input index,\n   *    produces an unlocking script suitable for a P2PKH locked output.\n   * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n   *\n   * @param {PrivateKey} approverPrivateKey - The private key used for signing the transaction.\n   * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n   * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n   * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n   * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n   * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n   */\n  unlock(\n    approverPrivateKey: PrivateKey,\n    userSigScript: Script,\n    signOutputs: \"all\" | \"none\" | \"single\" = \"all\",\n    anyoneCanPay = false,\n    sourceSatoshis?: number,\n    lockingScript?: Script\n  ): {\n    sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>;\n    estimateLength: () => Promise<182>;\n  } {\n    return {\n      sign: async (tx: Transaction, inputIndex: number) => {\n        let signatureScope = TransactionSignature.SIGHASH_FORKID;\n        if (signOutputs === \"all\") {\n          signatureScope |= TransactionSignature.SIGHASH_ALL;\n        }\n        if (signOutputs === \"none\") {\n          signatureScope |= TransactionSignature.SIGHASH_NONE;\n        }\n        if (signOutputs === \"single\") {\n          signatureScope |= TransactionSignature.SIGHASH_SINGLE;\n        }\n        if (anyoneCanPay) {\n          signatureScope |= TransactionSignature.SIGHASH_ANYONECANPAY;\n        }\n\n        const input = tx.inputs[inputIndex];\n\n        const otherInputs = tx.inputs.filter(\n          (_, index) => index !== inputIndex\n        );\n\n        const sourceTXID = input.sourceTXID\n          ? input.sourceTXID\n          : input.sourceTransaction?.id(\"hex\");\n        if (!sourceTXID) {\n          throw new Error(\n            \"The input sourceTXID or sourceTransaction is required for transaction signing.\"\n          );\n        }\n        sourceSatoshis ||=\n          input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis;\n        if (!sourceSatoshis) {\n          throw new Error(\n            \"The sourceSatoshis or input sourceTransaction is required for transaction signing.\"\n          );\n        }\n        lockingScript ||=\n          input.sourceTransaction?.outputs[input.sourceOutputIndex]\n            .lockingScript;\n        if (!lockingScript) {\n          throw new Error(\n            \"The lockingScript or input sourceTransaction is required for transaction signing.\"\n          );\n        }\n\n        const preimage = TransactionSignature.format({\n          sourceTXID,\n          sourceOutputIndex: input.sourceOutputIndex,\n          sourceSatoshis,\n          transactionVersion: tx.version,\n          otherInputs,\n          inputIndex,\n          outputs: tx.outputs,\n          inputSequence: input.sequence || 0xffffffff,\n          subscript: lockingScript,\n          lockTime: tx.lockTime,\n          scope: signatureScope,\n        });\n        const rawSignature = approverPrivateKey.sign(Hash.sha256(preimage));\n        const sig = new TransactionSignature(\n          rawSignature.r,\n          rawSignature.s,\n          signatureScope\n        );\n        const unlockScript = new UnlockingScript();\n        unlockScript.writeBin(sig.toChecksigFormat());\n        unlockScript.writeScript(userSigScript);\n        return unlockScript;\n      },\n      estimateLength: async () => {\n        // public key (1+33) + signature (1+73) + approver signature (1+73)\n        // Note: We add 1 to each element's length because of the associated OP_PUSH\n        return 182;\n      },\n    };\n  }\n}\n","import { Hash, OP, Script, Transaction, Utils } from '@bsv/sdk';\nimport {\n  Inscription,\n  MNEEConfig,\n  MneeInscription,\n  MneeSync,\n  ParsedCosigner,\n  TxHistory,\n  TxStatus,\n  TxType,\n} from '../mnee.types';\n\nexport const parseInscription = (script: Script) => {\n  let fromPos: number | undefined;\n  for (let i = 0; i < script.chunks.length; i++) {\n    const chunk = script.chunks[i];\n    if (\n      i >= 2 &&\n      chunk.data?.length === 3 &&\n      Utils.toUTF8(chunk.data) == 'ord' &&\n      script.chunks[i - 1].op == OP.OP_IF &&\n      script.chunks[i - 2].op == OP.OP_FALSE\n    ) {\n      fromPos = i + 1;\n    }\n  }\n  if (fromPos === undefined) return;\n\n  const insc = {\n    file: { hash: '', size: 0, type: '' },\n    fields: {},\n  } as Inscription;\n\n  for (let i = fromPos; i < script.chunks.length; i += 2) {\n    const field = script.chunks[i];\n    if (field.op == OP.OP_ENDIF) {\n      break;\n    }\n    if (field.op > OP.OP_16) return;\n    const value = script.chunks[i + 1];\n    if (value.op > OP.OP_PUSHDATA4) return;\n\n    if (field.data?.length) continue;\n\n    let fieldNo = 0;\n    if (field.op > OP.OP_PUSHDATA4 && field.op <= OP.OP_16) {\n      fieldNo = field.op - 80;\n    } else if (field.data?.length) {\n      fieldNo = field.data[0];\n    }\n    switch (fieldNo) {\n      case 0:\n        insc.file!.size = value.data?.length || 0;\n        if (!value.data?.length) break;\n        insc.file!.hash = Utils.toBase64(Hash.sha256(value.data));\n        insc.file!.content = value.data;\n        break;\n      case 1:\n        insc.file!.type = Buffer.from(value.data || []).toString();\n        break;\n    }\n  }\n\n  return insc;\n};\n\nexport const parseCosignerScripts = (scripts: any): ParsedCosigner[] => {\n  return scripts.map((script: any) => {\n    const chunks = script.chunks;\n    for (let i = 0; i <= chunks.length - 4; i++) {\n      if (\n        chunks.length > i + 6 &&\n        chunks[0 + i].op === OP.OP_DUP &&\n        chunks[1 + i].op === OP.OP_HASH160 &&\n        chunks[2 + i].data?.length === 20 &&\n        chunks[3 + i].op === OP.OP_EQUALVERIFY &&\n        chunks[4 + i].op === OP.OP_CHECKSIGVERIFY &&\n        chunks[5 + i].data?.length === 33 &&\n        chunks[6 + i].op === OP.OP_CHECKSIG\n      ) {\n        return {\n          cosigner: Utils.toHex(chunks[5 + i].data || []),\n          address: Utils.toBase58Check(chunks[2 + i].data || [], [0]),\n        };\n      } else if (\n        // P2PKH\n        chunks[0 + i].op === OP.OP_DUP &&\n        chunks[1 + i].op === OP.OP_HASH160 &&\n        chunks[2 + i].data?.length === 20 &&\n        chunks[3 + i].op === OP.OP_EQUALVERIFY &&\n        chunks[4 + i].op === OP.OP_CHECKSIG\n      ) {\n        return {\n          cosigner: '',\n          address: Utils.toBase58Check(chunks[2 + i].data || [], [0]),\n        };\n      }\n    }\n  });\n};\n\nexport const parseSyncToTxHistory = (sync: MneeSync, address: string, config: MNEEConfig): TxHistory | null => {\n  const txType: TxType = sync.senders.includes(address) ? 'send' : 'receive';\n  const txStatus: TxStatus = sync.height > 0 ? 'confirmed' : 'unconfirmed';\n\n  if (!sync.rawtx) return null;\n\n  const txArray = Utils.toArray(sync.rawtx, 'base64');\n  const txHex = Utils.toHex(txArray);\n  const tx = Transaction.fromHex(txHex);\n\n  const outScripts = tx.outputs.map((output) => output.lockingScript);\n  const mneeScripts = parseCosignerScripts(outScripts);\n  const parsedOutScripts = outScripts.map(parseInscription);\n  const mneeAddresses = mneeScripts.map((script) => script.address);\n\n  const feeAddressIndex = mneeAddresses.indexOf(config.feeAddress);\n  const sender = sync.senders[0]; // only one sender for now\n\n  let fee = 0;\n  const counterpartyAmounts = new Map<string, number>();\n\n  parsedOutScripts.forEach((parsedScript, index) => {\n    const content = parsedScript?.file?.content;\n    if (!content) return;\n\n    const inscriptionData = Utils.toUTF8(content);\n    if (!inscriptionData) return;\n\n    let inscriptionJson: MneeInscription;\n    try {\n      inscriptionJson = JSON.parse(inscriptionData);\n    } catch (err) {\n      console.error('Failed to parse inscription JSON:', err);\n      return;\n    }\n\n    if (inscriptionJson.p !== 'bsv-20' || inscriptionJson.id !== config.tokenId) return;\n\n    const inscriptionAmt = parseInt(inscriptionJson.amt, 10);\n    if (Number.isNaN(inscriptionAmt)) return;\n\n    if (feeAddressIndex === index && sender === address) {\n      fee += inscriptionAmt;\n      return;\n    }\n\n    const outAddr = mneeAddresses[index];\n    const prevAmt = counterpartyAmounts.get(outAddr) || 0;\n    counterpartyAmounts.set(outAddr, prevAmt + inscriptionAmt);\n  });\n\n  const amountSentToAddress = counterpartyAmounts.get(address) || 0;\n\n  if (txType === 'send') {\n    const senderAmt = counterpartyAmounts.get(sender) || 0;\n    counterpartyAmounts.set(sender, senderAmt - amountSentToAddress);\n  }\n\n  let counterparties: { address: string; amount: number }[] = [];\n  if (txType === 'receive') {\n    counterparties = [{ address: sender, amount: amountSentToAddress }];\n  } else {\n    counterparties = Array.from(counterpartyAmounts.entries())\n      .map(([addr, amt]) => ({ address: addr, amount: amt }))\n      .filter((cp) => cp.address !== address && cp.address !== config.feeAddress && cp.amount > 0);\n  }\n\n  const totalCounterpartyAmount = counterparties.reduce((sum, cp) => sum + cp.amount, 0);\n\n  return {\n    txid: sync.txid,\n    height: sync.height,\n    type: txType,\n    status: txStatus,\n    amount: totalCounterpartyAmount,\n    fee,\n    score: sync.score,\n    counterparties,\n  };\n};\n","import {\n  BroadcastFailure,\n  BroadcastResponse,\n  Hash,\n  P2PKH,\n  PrivateKey,\n  PublicKey,\n  Script,\n  Transaction,\n  TransactionSignature,\n  UnlockingScript,\n  Utils,\n} from '@bsv/sdk';\nimport {\n  Environment,\n  GetSignatures,\n  MNEEBalance,\n  MNEEConfig,\n  MneeInscription,\n  MNEEOperation,\n  MneeSync,\n  MNEEUtxo,\n  ParseTxResponse,\n  SendMNEE,\n  SignatureRequest,\n  SignatureResponse,\n  TxHistory,\n  TxHistoryResponse,\n  TxOperation,\n} from './mnee.types.js';\nimport CosignTemplate from './mneeCosignTemplate.js';\nimport * as jsOneSat from 'js-1sat-ord';\nimport { parseCosignerScripts, parseInscription, parseSyncToTxHistory } from './utils/helper.js';\n\nexport class MNEEService {\n  private mneeApiToken = '92982ec1c0975f31979da515d46bae9f';\n  private prodTokenId = 'ae59f3b898ec61acbdb6cc7a245fabeded0c094bf046f35206a3aec60ef88127_0';\n  private prodApprover = '020a177d6a5e6f3a8689acd2e313bd1cf0dcf5a243d1cc67b7218602aee9e04b2f';\n  private prodAddress = '1inHbiwj2jrEcZPiSYnfgJ8FmS1Bmk4Dh';\n  private devTokenId = '833a7720966a2a435db28d967385e8aa7284b6150ebb39482cc5228b73e1703f_0';\n  private devAddress = '1A1QNEkLuvAALsmG4Me3iubP8zb5C6jpv5';\n  private qaTokenId = '55cde0733049a226fdb6abc387ee9dcd036e859f7cbc69ab90050c0435139f00_0';\n  private qaAddress = '1BW7cejD27vDLiHsbK1Hvf1y4JTKvC1Yue';\n  private stageTokenId = '833a7720966a2a435db28d967385e8aa7284b6150ebb39482cc5228b73e1703f_0';\n  private stageAddress = '1AZNdbFYBDFTAEgzZMfPzANxyNrpGJZAUY';\n  private mneeApi = 'https://proxy-api.mnee.net';\n  private gorillaPoolApi = 'https://ordinals.1sat.app';\n  private mneeConfig: MNEEConfig | undefined;\n\n  constructor(apiToken?: string) {\n    if (apiToken) this.mneeApiToken = apiToken;\n    this.getConfig();\n  }\n\n  public async getConfig(): Promise<MNEEConfig | undefined> {\n    try {\n      const response = await fetch(`${this.mneeApi}/v1/config?auth_token=${this.mneeApiToken}`, { method: 'GET' });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      const data: MNEEConfig = await response.json();\n      this.mneeConfig = data;\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch config:', error);\n      return undefined;\n    }\n  }\n\n  public toAtomicAmount(amount: number): number {\n    if (!this.mneeConfig) throw new Error('Config not fetched');\n    return Math.round(amount * 10 ** this.mneeConfig.decimals);\n  }\n\n  public fromAtomicAmount(amount: number): number {\n    if (!this.mneeConfig) throw new Error('Config not fetched');\n    return amount / 10 ** this.mneeConfig.decimals;\n  }\n\n  private async createInscription(recipient: string, amount: number, config: MNEEConfig) {\n    const inscriptionData = {\n      p: 'bsv-20',\n      op: 'transfer',\n      id: config.tokenId,\n      amt: amount.toString(),\n    };\n    return {\n      lockingScript: jsOneSat.applyInscription(\n        new CosignTemplate().lock(recipient, PublicKey.fromString(config.approver)),\n        {\n          dataB64: Buffer.from(JSON.stringify(inscriptionData)).toString('base64'),\n          contentType: 'application/bsv-20',\n        },\n      ),\n      satoshis: 1,\n    };\n  }\n\n  private async getUtxos(address: string, ops: MNEEOperation[] = ['transfer', 'deploy+mint']): Promise<MNEEUtxo[]> {\n    try {\n      const response = await fetch(`${this.mneeApi}/v1/utxos?auth_token=${this.mneeApiToken}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify([address]),\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      const data: MNEEUtxo[] = await response.json();\n      if (ops.length) {\n        return data.filter((utxo) =>\n          ops.includes(utxo.data.bsv21.op.toLowerCase() as 'transfer' | 'burn' | 'deploy+mint'),\n        );\n      }\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch UTXOs:', error);\n      return [];\n    }\n  }\n\n  private async broadcast(tx: Transaction): Promise<BroadcastResponse | BroadcastFailure> {\n    const url = `${this.gorillaPoolApi}/v5/tx`;\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/octet-stream' },\n        body: Buffer.from(tx.toBinary()),\n      });\n      const body = await response.json();\n      if (!response.ok) {\n        return {\n          status: 'error',\n          code: response.status.toString(),\n          description: body.error || 'Unknown error',\n        } as BroadcastFailure;\n      }\n      return {\n        status: 'success',\n        txid: body.txid,\n        message: 'Transaction broadcast successfully',\n      } as BroadcastResponse;\n    } catch (error) {\n      console.error('Failed to broadcast:', error);\n      return {\n        status: 'error',\n        code: 'UNKNOWN',\n        description: error instanceof Error ? error.message : 'Unknown error',\n      } as BroadcastFailure;\n    }\n  }\n\n  private async fetchBeef(txid: string): Promise<Transaction> {\n    const resp = await fetch(`${this.gorillaPoolApi}/v5/tx/${txid}/beef`);\n    if (resp.status === 404) throw new Error('Transaction not found');\n    if (resp.status !== 200) {\n      throw new Error(`${resp.status} - Failed to fetch beef for tx ${txid}`);\n    }\n    const beef = [...Buffer.from(await resp.arrayBuffer())];\n    return Transaction.fromAtomicBEEF(beef);\n  }\n\n  private async getSignatures(\n    request: GetSignatures,\n    privateKey: PrivateKey,\n  ): Promise<{\n    sigResponses?: SignatureResponse[];\n    error?: { message: string; cause?: any };\n  }> {\n    try {\n      const DEFAULT_SIGHASH_TYPE = 65;\n      let tx: Transaction;\n      switch (request.format) {\n        case 'beef':\n          tx = Transaction.fromHexBEEF(request.rawtx);\n          break;\n        case 'ef':\n          tx = Transaction.fromHexEF(request.rawtx);\n          break;\n        default:\n          tx = Transaction.fromHex(request.rawtx);\n          break;\n      }\n      const sigResponses: SignatureResponse[] = request.sigRequests.flatMap((sigReq: SignatureRequest) => {\n        return [privateKey].map((privKey: PrivateKey) => {\n          const preimage = TransactionSignature.format({\n            sourceTXID: sigReq.prevTxid,\n            sourceOutputIndex: sigReq.outputIndex,\n            sourceSatoshis: sigReq.satoshis,\n            transactionVersion: tx.version,\n            otherInputs: tx.inputs.filter((_, index) => index !== sigReq.inputIndex),\n            inputIndex: sigReq.inputIndex,\n            outputs: tx.outputs,\n            inputSequence: tx.inputs[sigReq.inputIndex].sequence || 0,\n            subscript: sigReq.script\n              ? Script.fromHex(sigReq.script)\n              : new P2PKH().lock(privKey.toPublicKey().toAddress()),\n            lockTime: tx.lockTime,\n            scope: sigReq.sigHashType || DEFAULT_SIGHASH_TYPE,\n          });\n          const rawSignature = privKey.sign(Hash.sha256(preimage));\n          const sig = new TransactionSignature(\n            rawSignature.r,\n            rawSignature.s,\n            sigReq.sigHashType || DEFAULT_SIGHASH_TYPE,\n          );\n          return {\n            sig: Utils.toHex(sig.toChecksigFormat()),\n            pubKey: privKey.toPublicKey().toString(),\n            inputIndex: sigReq.inputIndex,\n            sigHashType: sigReq.sigHashType || DEFAULT_SIGHASH_TYPE,\n            csIdx: sigReq.csIdx,\n          };\n        });\n      });\n      return Promise.resolve({ sigResponses });\n    } catch (err: any) {\n      console.error('getSignatures error', err);\n      return {\n        error: {\n          message: err.message ?? 'unknown',\n          cause: err.cause,\n        },\n      };\n    }\n  }\n\n  public async transfer(request: SendMNEE[], wif: string): Promise<{ txid?: string; rawtx?: string; error?: string }> {\n    try {\n      const config = this.mneeConfig || (await this.getConfig());\n      if (!config) throw new Error('Config not fetched');\n\n      const totalAmount = request.reduce((sum, req) => sum + req.amount, 0);\n      if (totalAmount <= 0) return { error: 'Invalid amount' };\n      const totalAtomicTokenAmount = this.toAtomicAmount(totalAmount);\n\n      const privateKey = PrivateKey.fromWif(wif);\n      const address = privateKey.toAddress();\n      const utxos = await this.getUtxos(address);\n      const totalUtxoAmount = utxos.reduce((sum, utxo) => sum + (utxo.data.bsv21.amt || 0), 0);\n      if (totalUtxoAmount < totalAtomicTokenAmount) {\n        return { error: 'Insufficient MNEE balance' };\n      }\n\n      const fee =\n        request.find((req) => req.address === config.burnAddress) !== undefined\n          ? 0\n          : config.fees.find(\n              (fee: { min: number; max: number }) =>\n                totalAtomicTokenAmount >= fee.min && totalAtomicTokenAmount <= fee.max,\n            )?.fee;\n      if (fee === undefined) return { error: 'Fee ranges inadequate' };\n\n      const tx = new Transaction(1, [], [], 0);\n      let tokensIn = 0;\n      const signingAddresses: string[] = [];\n      let changeAddress = '';\n\n      while (tokensIn < totalAtomicTokenAmount + fee) {\n        const utxo = utxos.shift();\n        if (!utxo) return { error: 'Insufficient MNEE balance' };\n\n        const sourceTransaction = await this.fetchBeef(utxo.txid);\n        if (!sourceTransaction) return { error: 'Failed to fetch source transaction' };\n\n        signingAddresses.push(utxo.owners[0]);\n        changeAddress = changeAddress || utxo.owners[0];\n        tx.addInput({\n          sourceTXID: utxo.txid,\n          sourceOutputIndex: utxo.vout,\n          sourceTransaction,\n          unlockingScript: new UnlockingScript(),\n        });\n        tokensIn += utxo.data.bsv21.amt;\n      }\n\n      for (const req of request) {\n        tx.addOutput(await this.createInscription(req.address, this.toAtomicAmount(req.amount), config));\n      }\n      if (fee > 0) tx.addOutput(await this.createInscription(config.feeAddress, fee, config));\n\n      const change = tokensIn - totalAtomicTokenAmount - fee;\n      if (change > 0) {\n        tx.addOutput(await this.createInscription(changeAddress, change, config));\n      }\n\n      const sigRequests: SignatureRequest[] = tx.inputs.map((input, index) => {\n        if (!input.sourceTXID) throw new Error('Source TXID is undefined');\n        return {\n          prevTxid: input.sourceTXID,\n          outputIndex: input.sourceOutputIndex,\n          inputIndex: index,\n          address: signingAddresses[index],\n          script: input.sourceTransaction?.outputs[input.sourceOutputIndex].lockingScript.toHex(),\n          satoshis: input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis || 1,\n          sigHashType:\n            TransactionSignature.SIGHASH_ALL |\n            TransactionSignature.SIGHASH_ANYONECANPAY |\n            TransactionSignature.SIGHASH_FORKID,\n        };\n      });\n\n      const rawtx = tx.toHex();\n      const res = await this.getSignatures({ rawtx, sigRequests }, privateKey);\n      if (!res?.sigResponses) return { error: 'Failed to get signatures' };\n\n      for (const sigResponse of res.sigResponses) {\n        tx.inputs[sigResponse.inputIndex].unlockingScript = new Script()\n          .writeBin(Utils.toArray(sigResponse.sig, 'hex'))\n          .writeBin(Utils.toArray(sigResponse.pubKey, 'hex'));\n      }\n\n      const base64Tx = Utils.toBase64(tx.toBinary());\n      const response = await fetch(`${this.mneeApi}/v1/transfer?auth_token=${this.mneeApiToken}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ rawtx: base64Tx }),\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      const { rawtx: responseRawtx } = await response.json();\n      if (!responseRawtx) return { error: 'Failed to broadcast transaction' };\n\n      const decodedBase64AsBinary = Utils.toArray(responseRawtx, 'base64');\n      const tx2 = Transaction.fromBinary(decodedBase64AsBinary);\n      await this.broadcast(tx2);\n\n      return { txid: tx2.id('hex'), rawtx: Utils.toHex(decodedBase64AsBinary) };\n    } catch (error) {\n      let errorMessage = 'Transaction submission failed';\n      if (error instanceof Error) {\n        errorMessage = error.message;\n        if (error.message.includes('HTTP error')) {\n          // Add more specific error handling if needed based on response status\n          console.error('HTTP error details:', error);\n        }\n      }\n      console.error('Failed to transfer tokens:', errorMessage);\n      return { error: errorMessage };\n    }\n  }\n\n  public async getBalance(address: string): Promise<MNEEBalance> {\n    try {\n      const config = this.mneeConfig || (await this.getConfig());\n      if (!config) throw new Error('Config not fetched');\n      const res = await this.getUtxos(address);\n      const balance = res.reduce((acc, utxo) => {\n        if (utxo.data.bsv21.op === 'transfer') {\n          acc += utxo.data.bsv21.amt;\n        }\n        return acc;\n      }, 0);\n\n      const decimalAmount = this.fromAtomicAmount(balance);\n      return { amount: balance, decimalAmount };\n    } catch (error) {\n      console.error('Failed to fetch balance:', error);\n      return { amount: 0, decimalAmount: 0 };\n    }\n  }\n\n  public async validateMneeTx(rawTx: string, request?: SendMNEE[]) {\n    try {\n      const config = this.mneeConfig || (await this.getConfig());\n      if (!config) throw new Error('Config not fetched');\n      const tx = Transaction.fromHex(rawTx);\n      const scripts = tx.outputs.map((output) => output.lockingScript);\n      const parsedScripts = parseCosignerScripts(scripts);\n\n      if (!request) {\n        parsedScripts.forEach((parsed) => {\n          if (parsed?.cosigner !== '' && parsed?.cosigner !== config.approver) {\n            throw new Error('Invalid or missing cosigner');\n          }\n        });\n      } else {\n        request.forEach((req, idx) => {\n          const { address, amount } = req;\n          const cosigner = parsedScripts.find((parsed) => parsed?.cosigner === config.approver);\n          if (!cosigner) {\n            throw new Error(`Cosigner not found for address: ${address} at index: ${idx}`);\n          }\n\n          const addressFromScript = parsedScripts.find((parsed) => parsed?.address === address);\n          if (!addressFromScript) {\n            throw new Error(`Address not found in script for address: ${address} at index: ${idx}`);\n          }\n          const script = tx.outputs[idx].lockingScript;\n          const inscription = parseInscription(script);\n          const content = inscription?.file?.content;\n          if (!content) throw new Error('Invalid inscription content');\n          const inscriptionData = Utils.toUTF8(content);\n          if (!inscriptionData) throw new Error('Invalid inscription content');\n          const inscriptionJson: MneeInscription = JSON.parse(inscriptionData);\n          if (inscriptionJson.p !== 'bsv-20') throw new Error(`Invalid bsv 20 protocol: ${inscriptionJson.p}`);\n          if (inscriptionJson.op !== 'transfer') throw new Error(`Invalid operation: ${inscriptionJson.op}`);\n          if (inscriptionJson.id !== config.tokenId) throw new Error(`Invalid token id: ${inscriptionJson.id}`);\n          if (inscriptionJson.amt !== this.toAtomicAmount(amount).toString()) {\n            throw new Error(`Invalid amount: ${inscriptionJson.amt}`);\n          }\n        });\n      }\n\n      return true;\n    } catch (error) {\n      console.error(error);\n      return false;\n    }\n  }\n\n  private async getMneeSyncs(address: string, fromScore = 0, limit = 100): Promise<MneeSync[] | undefined> {\n    try {\n      const response = await fetch(\n        `${this.mneeApi}/v1/sync?auth_token=${this.mneeApiToken}&from=${fromScore}&limit=${limit}`,\n        {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify([address]),\n        },\n      );\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      const data: MneeSync[] = await response.json();\n      return data;\n    } catch (error) {\n      console.error('Failed to fetch config:', error);\n      return undefined;\n    }\n  }\n\n  public async getRecentTxHistory(address: string, fromScore?: number, limit?: number): Promise<TxHistoryResponse> {\n    try {\n      const config = this.mneeConfig || (await this.getConfig());\n      if (!config) throw new Error('Config not fetched');\n\n      const syncs = await this.getMneeSyncs(address, fromScore, limit);\n      if (!syncs || syncs.length === 0) return { history: [], nextScore: fromScore || 0 };\n\n      const txHistory: TxHistory[] = [];\n      for (const sync of syncs) {\n        const historyItem = parseSyncToTxHistory(sync, address, config);\n        if (historyItem) {\n          txHistory.push(historyItem);\n        }\n      }\n\n      const sortedByHeight = txHistory.sort((a, b) => b.height - a.height);\n      const sortedUnconfirmedFirst = sortedByHeight.sort((a, b) => (a.status === 'unconfirmed' ? -1 : 1));\n\n      if (sortedUnconfirmedFirst.length === 0) return { history: [], nextScore: fromScore || 0 };\n      if (limit && sortedUnconfirmedFirst.length > limit) {\n        return {\n          history: sortedUnconfirmedFirst.slice(0, limit),\n          nextScore: sortedUnconfirmedFirst[limit - 1].score,\n        };\n      }\n\n      const nextScore = txHistory[txHistory.length - 1].score;\n\n      return { history: sortedUnconfirmedFirst, nextScore };\n    } catch (error) {\n      console.error('Failed to fetch tx history:', error);\n      return { history: [], nextScore: fromScore || 0 };\n    }\n  }\n\n  public async parseTx(txid: string): Promise<ParseTxResponse> {\n    const config = this.mneeConfig || (await this.getConfig());\n    if (!config) throw new Error('Config not fetched');\n    const tx = await this.fetchBeef(txid);\n    if (!tx) throw new Error('Failed to fetch transaction');\n    const outScripts = tx.outputs.map((output) => output.lockingScript);\n    const sourceTxs = tx.inputs.map((input) => {\n      return { txid: input.sourceTXID, vout: input.sourceOutputIndex };\n    });\n\n    let inputs = [];\n    let outputs = [];\n    let inputTotal = 0n;\n    let outputTotal = 0n;\n    let environment: Environment = 'prod';\n    let type: TxOperation = 'transfer';\n    for (const tx of sourceTxs) {\n      if (!tx.txid) continue;\n      const fetchedTx = await this.fetchBeef(tx.txid);\n      const output = fetchedTx.outputs[tx.vout];\n      const parsedCosigner = parseCosignerScripts([output.lockingScript])[0];\n      if (parsedCosigner?.address === config.mintAddress) {\n        type = txid === config.tokenId.split('_')[0] ? 'deploy' : 'mint';\n      }\n      const insc = parseInscription(output.lockingScript);\n      const content = insc?.file?.content;\n      if (!content) continue;\n      const inscriptionData = Utils.toUTF8(content);\n      if (!inscriptionData) continue;\n      const inscriptionJson: MneeInscription = JSON.parse(inscriptionData);\n      if (inscriptionJson) {\n        const isProdToken = inscriptionJson.id === this.prodTokenId;\n        const isProdApprover = parsedCosigner.cosigner === this.prodApprover;\n        const isEmptyCosigner = parsedCosigner.cosigner === '';\n        const isMint = inscriptionJson.op === 'deploy+mint';\n        const isProdAddress = parsedCosigner.address === this.prodAddress;\n        const isDevAddress = parsedCosigner.address === this.devAddress;\n        const isQaAddress = parsedCosigner.address === this.qaAddress;\n        const isStageAddress = parsedCosigner.address === this.stageAddress;\n\n        if (!isProdToken || !isProdApprover) {\n          if (isEmptyCosigner && isMint && isProdAddress) {\n            environment = 'prod';\n            type = 'mint';\n          } else {\n            environment = 'test';\n          }\n        }\n\n        if (type === 'transfer' && (isProdAddress || isDevAddress || isQaAddress || isStageAddress)) {\n          type = 'mint';\n        }\n\n        inputTotal += BigInt(inscriptionJson.amt);\n        inputs.push({\n          address: parsedCosigner.address,\n          amount: parseInt(inscriptionJson.amt),\n        });\n      }\n    }\n\n    for (const script of outScripts) {\n      const parsedCosigner = parseCosignerScripts([script])[0];\n      const insc = parseInscription(script);\n      const content = insc?.file?.content;\n      if (!content) continue;\n      const inscriptionData = Utils.toUTF8(content);\n      if (!inscriptionData) continue;\n      const inscriptionJson = JSON.parse(inscriptionData);\n      if (inscriptionJson) {\n        if (inscriptionJson.op === 'burn') {\n          type = 'burn';\n        }\n        const isProdToken = inscriptionJson.id === this.prodTokenId;\n        const isProdApprover = parsedCosigner.cosigner === this.prodApprover;\n        const isEmptyCosigner = parsedCosigner.cosigner === '';\n        const isProdAddress = parsedCosigner.address === this.prodAddress;\n        const isDeploy = inscriptionJson.op === 'deploy+mint';\n\n        if (isDeploy) {\n          type = 'deploy';\n        }\n\n        if (!isProdToken || !isProdApprover) {\n          if (isEmptyCosigner && isProdAddress) {\n            environment = 'prod';\n          } else {\n            environment = 'test';\n          }\n        }\n        outputTotal += BigInt(inscriptionJson.amt);\n        outputs.push({\n          address: parsedCosigner.address,\n          amount: parseInt(inscriptionJson.amt),\n        });\n      }\n    }\n\n    if (type !== 'deploy' && inputTotal !== outputTotal) {\n      throw new Error('Inputs and outputs are not equal');\n    }\n\n    if (txid === this.prodTokenId.split('_')[0]) {\n      environment = 'prod';\n    } else if ([this.devTokenId, this.qaTokenId, this.stageTokenId].some(id => txid === id.split('_')[0])) {\n      environment = 'test';\n    }\n\n    return { txid, environment, type, inputs, outputs };\n  }\n}\n","import { MNEEService } from './mneeService.js';\nimport {\n  MNEEBalance,\n  MNEEConfig,\n  ParseTxResponse,\n  SendMNEE,\n  TransferResponse,\n  TxHistoryResponse,\n} from './mnee.types.js';\nexport * from './mnee.types.js';\n\nexport interface MneeInterface {\n  config(): Promise<MNEEConfig | undefined>;\n  balance(address: string): Promise<MNEEBalance>;\n  validateMneeTx(rawtx: string, request?: SendMNEE[]): Promise<boolean>;\n  transfer(request: SendMNEE[], wif: string): Promise<TransferResponse>;\n  toAtomicAmount(amount: number): number;\n  fromAtomicAmount(amount: number): number;\n  recentTxHistory(address: string, fromScore?: number, limit?: number): Promise<TxHistoryResponse>;\n  parseTx(txid: string): Promise<ParseTxResponse>;\n}\n\n/**\n * Represents the Mnee class that provides methods to interact with the MNEE service.\n */\nexport default class Mnee implements MneeInterface {\n  private service: MNEEService;\n\n  constructor(apiToken?: string) {\n    this.service = new MNEEService(apiToken);\n  }\n\n  /**\n   * Validates an MNEE transaction.\n   *\n   * @param rawtx - The raw transaction to validate.\n   * @param request - An array of SendMNEE objects representing the transfer details. Use this parameter to validate the transaction against the specified transfer details. If it is not provided, it will only validate that the transaction is well-formed with the cosigner.\n   * @returns A promise that resolves to a boolean indicating whether the transaction is valid.\n   */\n  async validateMneeTx(rawtx: string, request?: SendMNEE[]): Promise<boolean> {\n    return this.service.validateMneeTx(rawtx, request);\n  }\n\n  /**\n   * Converts a given amount to its atomic representation based on the specified number.\n   *\n   * @param amount - The amount to be converted.\n   * @returns The atomic representation of the given amount.\n   *\n   * @example\n   * ```typescript\n   * toAtomicAmount(1.5); // 150000\n   * ```\n   */\n  toAtomicAmount(amount: number): number {\n    return this.service.toAtomicAmount(amount);\n  }\n\n  /**\n   * Converts a given atomic amount to its human-readable representation.\n   *\n   * @param amount - The atomic amount to be converted.\n   * @returns The human-readable representation of the given atomic amount.\n   *\n   * @example\n   * ```typescript\n   * fromAtomicAmount(150000); // 1.5\n   * ```\n   */\n  fromAtomicAmount(amount: number): number {\n    return this.service.fromAtomicAmount(amount);\n  }\n\n  /**\n   * Retrieves the configuration for the MNEE service.\n   *\n   * @returns {Promise<MNEEConfig | undefined>} A promise that resolves to the MNEE configuration object,\n   * or undefined if the configuration could not be retrieved.\n   */\n  async config(): Promise<MNEEConfig | undefined> {\n    return this.service.getConfig();\n  }\n\n  /**\n   * Retrieves the balance for a given address.\n   *\n   * @param address - The address to retrieve the balance for.\n   * @returns A promise that resolves to an MNEEBalance object containing the balance information.\n   */\n  async balance(address: string): Promise<MNEEBalance> {\n    return this.service.getBalance(address);\n  }\n\n  /**\n   * Transfers the specified MNEE tokens using the provided WIF (Wallet Import Format) key.\n   *\n   * @param {SendMNEE[]} request - An array of SendMNEE objects representing the transfer details.\n   * @param {string} wif - The Wallet Import Format key used to authorize the transfer.\n   * @returns {Promise<TransferResponse>} A promise that resolves to a TransferResponse object containing the result of the transfer.\n   */\n  async transfer(request: SendMNEE[], wif: string): Promise<TransferResponse> {\n    return this.service.transfer(request, wif);\n  }\n\n  /**\n   * Retrieves the recent transaction history for a given address.\n   *\n   * @param address - The address to retrieve the transaction history for.\n   * @param fromScore - The starting score to retrieve the transaction history from.\n   * @param limit - The maximum number of transactions to retrieve.\n   * @returns A promise that resolves to a TxHistoryResponse object containing the transaction\n   * history and the next score to retrieve additional transactions.\n   */\n  async recentTxHistory(address: string, fromScore?: number, limit?: number): Promise<TxHistoryResponse> {\n    return this.service.getRecentTxHistory(address, fromScore, limit);\n  }\n\n  /**\n   * Parses a transaction based on the provided transaction ID.\n   *\n   * @param txid - The unique identifier of the transaction to be parsed.\n   * @returns A promise that resolves to a `ParseTxResponse` containing the parsed transaction details.\n   */\n  async parseTx(txid: string): Promise<ParseTxResponse> {\n    return this.service.parseTx(txid);\n  }\n}\n"],"names":["CosignTemplate","lock","userPKHash","approverPubKey","pkhash","hash","Utils","fromBase58Check","prefix","Error","data","lockingScript","LockingScript","writeOpCode","OP","OP_DUP","OP_HASH160","writeBin","OP_EQUALVERIFY","OP_CHECKSIGVERIFY","encode","OP_CHECKSIG","userUnlock","userPrivateKey","signOutputs","anyoneCanPay","sourceSatoshis","sign","async","tx","inputIndex","_input$sourceTransact","_input$sourceTransact2","_input$sourceTransact3","signatureScope","TransactionSignature","SIGHASH_FORKID","SIGHASH_ALL","SIGHASH_NONE","SIGHASH_SINGLE","SIGHASH_ANYONECANPAY","input","inputs","otherInputs","filter","_","index","sourceTXID","sourceTransaction","id","outputs","sourceOutputIndex","satoshis","preimage","format","transactionVersion","version","inputSequence","sequence","subscript","lockTime","scope","rawSignature","Hash","sha256","sig","r","s","unlockScript","UnlockingScript","toChecksigFormat","toPublicKey","estimateLength","unlock","approverPrivateKey","userSigScript","_input$sourceTransact4","_input$sourceTransact5","_input$sourceTransact6","writeScript","parseInscription","script","_value$data","_value$data2","fromPos","i","chunks","length","_chunk$data","chunk","toUTF8","op","OP_IF","OP_FALSE","undefined","insc","file","size","type","fields","_field$data","_field$data2","field","OP_ENDIF","OP_16","value","OP_PUSHDATA4","fieldNo","toBase64","content","Buffer","from","toString","parseCosignerScripts","scripts","map","_chunks$data","_chunks$data2","_chunks$data3","cosigner","toHex","address","toBase58Check","parseSyncToTxHistory","sync","config","txType","senders","includes","txStatus","height","rawtx","txArray","toArray","txHex","outScripts","Transaction","fromHex","output","mneeScripts","parsedOutScripts","mneeAddresses","feeAddressIndex","indexOf","feeAddress","sender","fee","counterpartyAmounts","Map","forEach","parsedScript","_parsedScript$file","inscriptionData","inscriptionJson","JSON","parse","err","console","error","p","tokenId","inscriptionAmt","parseInt","amt","Number","isNaN","outAddr","prevAmt","get","set","amountSentToAddress","senderAmt","counterparties","amount","Array","entries","addr","cp","totalCounterpartyAmount","reduce","sum","txid","status","score","MNEEService","constructor","apiToken","this","mneeApiToken","prodTokenId","prodApprover","prodAddress","devTokenId","devAddress","qaTokenId","qaAddress","stageTokenId","stageAddress","mneeApi","gorillaPoolApi","mneeConfig","getConfig","response","fetch","method","ok","json","toAtomicAmount","Math","round","decimals","fromAtomicAmount","createInscription","recipient","jsOneSat","applyInscription","PublicKey","fromString","approver","dataB64","stringify","contentType","getUtxos","ops","headers","body","utxo","bsv21","toLowerCase","broadcast","url","toBinary","message","code","description","fetchBeef","resp","beef","arrayBuffer","fromAtomicBEEF","getSignatures","request","privateKey","DEFAULT_SIGHASH_TYPE","fromHexBEEF","fromHexEF","sigResponses","sigRequests","flatMap","sigReq","privKey","prevTxid","outputIndex","Script","P2PKH","toAddress","sigHashType","pubKey","csIdx","Promise","resolve","_err$message","cause","transfer","wif","_config$fees$find","totalAmount","req","totalAtomicTokenAmount","PrivateKey","fromWif","utxos","find","burnAddress","fees","min","max","tokensIn","signingAddresses","changeAddress","shift","push","owners","addInput","vout","unlockingScript","addOutput","change","res","sigResponse","base64Tx","responseRawtx","decodedBase64AsBinary","tx2","fromBinary","errorMessage","getBalance","balance","acc","decimalAmount","validateMneeTx","rawTx","parsedScripts","idx","_inscription$file","parsed","inscription","getMneeSyncs","fromScore","limit","getRecentTxHistory","syncs","history","nextScore","txHistory","historyItem","sortedUnconfirmedFirst","sort","a","b","slice","parseTx","sourceTxs","inputTotal","outputTotal","environment","_insc$file","parsedCosigner","mintAddress","split","isProdAddress","BigInt","_insc$file2","some","Mnee","service","recentTxHistory"],"mappings":"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"}